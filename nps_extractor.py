#!/usr/bin/env python3
"""
NPS Extractor - Conecta e extrai dados do Google Sheets
Autor: Claude Code
Data: 09/07/2025
"""

import pandas as pd
import gspread
from google.oauth2.service_account import Credentials
import requests
from urllib.parse import urlparse
import re
from datetime import datetime
import io
import os
from service_account_config import ServiceAccountConfig
try:
    from auth_automatico import AuthAutomatico
except ImportError:
    AuthAutomatico = None


class NPSExtractor:
    """Classe para extrair dados NPS do Google Sheets"""
    
    def __init__(self, auth_method='auto'):
        """Inicializa o extrator
        
        Args:
            auth_method: 'auto', 'service_account', 'oauth2', 'public'
        """
        self.gc = None
        self.dados = None
        self.auth_method = auth_method
        self.method_used = None
        
        # Configura autentica√ß√£o
        if auth_method == 'auto':
            self._setup_auto_auth()
        elif auth_method == 'service_account':
            self._setup_service_account()
        elif auth_method == 'oauth2':
            self._setup_oauth2()
        
    def conectar_sheets(self, url):
        """
        Conecta com o Google Sheets usando Service Account ou m√©todo p√∫blico
        
        Args:
            url: URL do Google Sheets
            
        Returns:
            bool: True se conectado com sucesso
        """
        try:
            print(f"üîó Conectando com: {url}")
            
            # Usa m√©todo dispon√≠vel
            if self.gc and self.method_used in ['service_account', 'oauth2']:
                return self._conectar_com_auth(url)
            
            # Fallback: m√©todo p√∫blico
            return self._conectar_publico(url)
            
        except Exception as e:
            print(f"‚ùå Erro na conex√£o: {str(e)}")
            return False
    
    def _setup_auto_auth(self):
        """Configura autentica√ß√£o autom√°tica (prioridade: Auth Autom√°tico > Service Account > P√∫blico)"""
        # Tenta Auth Autom√°tico primeiro (suas credenciais OAuth2)
        if os.path.exists('credentials/token_automatico.json'):
            if self._setup_auth_automatico():
                return
        
        # Depois Service Account
        if os.path.exists('credentials/service-account.json'):
            if self._setup_service_account():
                return
        
        # Fallback: m√©todo p√∫blico
        print("‚ö†Ô∏è Usando m√©todo p√∫blico (apenas planilhas p√∫blicas)")
        self.method_used = 'public'
    
    def _setup_service_account(self):
        """Configura Service Account"""
        try:
            if os.path.exists('credentials/service-account.json'):
                print("üîê Configurando Service Account...")
                config = ServiceAccountConfig()
                if config.setup_credentials():
                    self.gc = config.get_client()
                    self.method_used = 'service_account'
                    print("‚úÖ Service Account configurado!")
                    return True
                else:
                    print("‚ö†Ô∏è Erro na configura√ß√£o Service Account")
            else:
                print("‚ö†Ô∏è Service Account n√£o encontrado")
                
        except Exception as e:
            print(f"‚ö†Ô∏è Erro Service Account: {str(e)}")
        
        return False
    
    def _setup_auth_automatico(self):
        """Configura Auth Autom√°tico (suas credenciais autom√°ticas)"""
        try:
            if AuthAutomatico is None:
                print("‚ö†Ô∏è Auth Autom√°tico n√£o dispon√≠vel")
                return False
                
            print("üîë Configurando Auth Autom√°tico (suas credenciais)...")
            config = AuthAutomatico()
            
            if config.conectar_automatico():
                self.gc = config.get_client()
                self.method_used = 'auth_automatico'
                print("‚úÖ Auth Autom√°tico configurado!")
                return True
            else:
                print("‚ö†Ô∏è Auth Autom√°tico n√£o configurado")
                
        except Exception as e:
            print(f"‚ö†Ô∏è Erro Auth Autom√°tico: {str(e)}")
        
        return False
    
    def _conectar_com_auth(self, url):
        """Conecta usando autentica√ß√£o e extrai TODOS os dados dispon√≠veis"""
        try:
            method_name = self._get_method_name()
            print(f"üîê Conectando com {method_name}...")
            
            # Extrai ID da planilha
            sheet_id = self._extrair_sheet_id(url)
            if not sheet_id:
                print("‚ùå ID da planilha n√£o encontrado")
                return False
            
            # Abre planilha
            spreadsheet = self.gc.open_by_key(sheet_id)
            
            # Lista todas as abas dispon√≠veis
            worksheets = spreadsheet.worksheets()
            print(f"üìã Encontradas {len(worksheets)} abas: {[ws.title for ws in worksheets]}")
            
            # Prioriza primeira aba ou aba com mais dados
            worksheet = self._selecionar_melhor_aba(worksheets)
            print(f"üìä Usando aba: '{worksheet.title}'")
            
            # Extra√ß√£o completa com m√∫ltiplos m√©todos
            dados_completos = self._extrair_dados_completos(worksheet)
            
            if dados_completos is None or len(dados_completos) == 0:
                print("‚ùå Nenhum dado v√°lido encontrado")
                return False
            
            self.dados = dados_completos
            print(f"‚úÖ {len(self.dados)} registros extra√≠dos com {len(self.dados.columns)} colunas")
            print(f"üìã Colunas: {list(self.dados.columns)}")
            
            return True
            
        except Exception as e:
            print(f"‚ùå Erro {self._get_method_name()}: {str(e)}")
            print("üîÑ Tentando m√©todo p√∫blico...")
            return self._conectar_publico(url)
    
    def _get_method_name(self):
        """Retorna nome do m√©todo de autentica√ß√£o"""
        if self.method_used == 'service_account':
            return "Service Account"
        elif self.method_used == 'auth_automatico':
            return "OAuth2 (suas credenciais)"
        else:
            return "OAuth2"
    
    def _selecionar_melhor_aba(self, worksheets):
        """Seleciona a aba com mais dados relevantes"""
        melhor_aba = worksheets[0]  # Padr√£o: primeira aba
        maior_linhas = 0
        
        for ws in worksheets:
            try:
                # Conta linhas com dados (evita contar linhas vazias)
                valores = ws.get_all_values()
                linhas_com_dados = len([linha for linha in valores if any(cel.strip() for cel in linha)])
                
                print(f"üìä Aba '{ws.title}': {linhas_com_dados} linhas com dados")
                
                if linhas_com_dados > maior_linhas:
                    maior_linhas = linhas_com_dados
                    melhor_aba = ws
                    
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao analisar aba '{ws.title}': {str(e)}")
                continue
        
        return melhor_aba
    
    def _extrair_dados_completos(self, worksheet):
        """Extrai TODOS os dados usando m√∫ltiplos m√©todos"""
        try:
            # M√©todo 1: get_all_records (preserva tipos)
            print("üîç Tentando extra√ß√£o com get_all_records...")
            try:
                records = worksheet.get_all_records(empty_value='', head=1)
                if records:
                    df = pd.DataFrame(records)
                    print(f"‚úÖ M√©todo 1: {len(df)} registros extra√≠dos")
                    return self._limpar_dados_completos(df)
            except Exception as e:
                print(f"‚ö†Ô∏è M√©todo 1 falhou: {str(e)}")
            
            # M√©todo 2: get_all_values (matriz bruta)
            print("üîç Tentando extra√ß√£o com get_all_values...")
            try:
                valores = worksheet.get_all_values()
                if valores and len(valores) > 1:
                    # Primeira linha como cabe√ßalho
                    cabecalho = valores[0]
                    dados = valores[1:]
                    
                    # Remove linhas completamente vazias
                    dados_filtrados = [linha for linha in dados if any(cel.strip() for cel in linha)]
                    
                    df = pd.DataFrame(dados_filtrados, columns=cabecalho)
                    print(f"‚úÖ M√©todo 2: {len(df)} registros extra√≠dos")
                    return self._limpar_dados_completos(df)
            except Exception as e:
                print(f"‚ö†Ô∏è M√©todo 2 falhou: {str(e)}")
            
            # M√©todo 3: Range espec√≠fico (√∫ltima tentativa)
            print("üîç Tentando extra√ß√£o por range...")
            try:
                # Detecta range de dados
                range_dados = worksheet.get_all_values()
                if range_dados:
                    df = pd.DataFrame(range_dados[1:], columns=range_dados[0])
                    df = df.dropna(how='all')  # Remove linhas completamente vazias
                    print(f"‚úÖ M√©todo 3: {len(df)} registros extra√≠dos")
                    return self._limpar_dados_completos(df)
            except Exception as e:
                print(f"‚ö†Ô∏è M√©todo 3 falhou: {str(e)}")
            
            return None
            
        except Exception as e:
            print(f"‚ùå Erro na extra√ß√£o completa: {str(e)}")
            return None
    
    def _limpar_dados_completos(self, df):
        """Limpeza avan√ßada mantendo TODOS os dados relevantes"""
        try:
            print(f"üßπ Limpando dados: {len(df)} registros, {len(df.columns)} colunas")
            
            # Remove apenas linhas completamente vazias
            df = df.dropna(how='all')
            
            # Normaliza nomes de colunas (remove caracteres especiais)
            df.columns = df.columns.str.strip()
            df.columns = df.columns.str.replace('\n', ' ')
            df.columns = df.columns.str.replace('\r', ' ')
            
            # EXTRA√á√ÉO UNIVERSAL - Mant√©m TODAS as colunas de QUALQUER planilha
            colunas_corrigidas = {}
            for col in df.columns:
                col_limpa = col.strip()
                
                # Remove apenas caracteres que causam problemas t√©cnicos
                col_limpa = col_limpa.replace('\n', ' ')
                col_limpa = col_limpa.replace('\r', ' ')
                col_limpa = col_limpa.replace('\t', ' ')
                
                # Corrige apenas encoding comum (mant√©m nomes originais)
                col_limpa = col_limpa.replace('Avalia√É¬ß√É¬£o', 'Avalia√ß√£o')
                col_limpa = col_limpa.replace('Coment√É¬°rio', 'Coment√°rio')
                col_limpa = col_limpa.replace('Situa√É¬ß√É¬£o', 'Situa√ß√£o')
                col_limpa = col_limpa.replace('Resou√É¬ß√É¬£o', 'Resolu√ß√£o')
                col_limpa = col_limpa.replace('Informa√É¬ß√É¬£o', 'Informa√ß√£o')
                col_limpa = col_limpa.replace('Descri√É¬ß√É¬£o', 'Descri√ß√£o')
                
                # Remove espa√ßos extras mas MANT√âM o nome original
                col_limpa = ' '.join(col_limpa.split())
                
                colunas_corrigidas[col] = col_limpa
            
            df = df.rename(columns=colunas_corrigidas)
            
            # Converte datas automaticamente
            for col in df.columns:
                if any(palavra in col.lower() for palavra in ['data', 'date', 'timestamp', 'hora']):
                    try:
                        df[col] = pd.to_datetime(df[col], errors='coerce')
                    except:
                        pass
            
            # Limpa espa√ßos em strings
            for col in df.select_dtypes(include=['object']).columns:
                df[col] = df[col].astype(str).str.strip()
                # Remove linhas onde a coluna principal est√° vazia
                if col.lower() in ['nome', 'cliente', 'vendedor']:
                    df = df[df[col] != '']
            
            print(f"‚úÖ Dados limpos: {len(df)} registros v√°lidos")
            return df
            
        except Exception as e:
            print(f"‚ùå Erro na limpeza: {str(e)}")
            return df  # Retorna dados originais se limpeza falhar
    
    def _conectar_publico(self, url):
        """Conecta usando m√©todo p√∫blico com extra√ß√£o robusta"""
        try:
            print("üåê Conectando com m√©todo p√∫blico...")
            
            # Extrai ID da planilha
            sheet_id = self._extrair_sheet_id(url)
            if not sheet_id:
                print("‚ùå Erro: ID da planilha n√£o encontrado")
                return False
            
            # Tenta m√∫ltiplos formatos de export
            formatos = [
                ('CSV', f"https://docs.google.com/spreadsheets/d/{sheet_id}/export?format=csv"),
                ('TSV', f"https://docs.google.com/spreadsheets/d/{sheet_id}/export?format=tsv"),
                ('CSV com gid=0', f"https://docs.google.com/spreadsheets/d/{sheet_id}/export?format=csv&gid=0")
            ]
            
            for formato, export_url in formatos:
                try:
                    print(f"üîç Tentando formato {formato}...")
                    
                    response = requests.get(export_url, timeout=30)
                    
                    if response.status_code == 200 and response.text.strip():
                        print(f"‚úÖ Dados obtidos via {formato}")
                        
                        # Detecta separador
                        separador = ',' if formato.startswith('CSV') else '\t'
                        
                        # M√∫ltiplos encodings
                        encodings = ['utf-8', 'latin-1', 'cp1252', 'iso-8859-1']
                        
                        for encoding in encodings:
                            try:
                                # Decodifica com encoding espec√≠fico
                                texto_decodificado = response.content.decode(encoding)
                                
                                # Carrega dados
                                self.dados = pd.read_csv(
                                    io.StringIO(texto_decodificado), 
                                    sep=separador,
                                    encoding=None,  # J√° decodificado
                                    na_values=['', 'NA', 'N/A', 'null', 'NULL'],
                                    keep_default_na=True,
                                    dtype=str  # Mant√©m como string para preservar dados
                                )
                                
                                # Aplica limpeza robusta
                                self.dados = self._limpar_dados_completos(self.dados)
                                
                                if len(self.dados) > 0:
                                    print(f"‚úÖ {len(self.dados)} registros extra√≠dos via m√©todo p√∫blico")
                                    print(f"üìã Colunas encontradas: {list(self.dados.columns)}")
                                    return True
                                    
                            except Exception as e:
                                print(f"‚ö†Ô∏è Encoding {encoding} falhou: {str(e)[:50]}...")
                                continue
                        
                    else:
                        print(f"‚ö†Ô∏è {formato} retornou c√≥digo {response.status_code}")
                        
                except Exception as e:
                    print(f"‚ö†Ô∏è Erro em {formato}: {str(e)[:50]}...")
                    continue
            
            print("‚ùå Todos os m√©todos p√∫blicos falharam")
            print("üí° Verifique se a planilha est√° p√∫blica e tente OAuth2")
            return False
                
        except Exception as e:
            print(f"‚ùå Erro cr√≠tico na conex√£o p√∫blica: {str(e)}")
            return False
    
    def extrair_avaliacoes(self):
        """
        Extrai TODOS os dados para an√°lise completa de p√≥s-venda
        
        Returns:
            pandas.DataFrame: Todos os dados para an√°lise IA
        """
        if self.dados is None:
            print("‚ùå Erro: Dados n√£o carregados")
            return None
        
        try:
            print("üîç Extraindo TODOS os dados para an√°lise p√≥s-venda...")
            
            # Retorna TODOS os dados sem filtros para an√°lise completa
            dados_completos = self.dados.copy()
            
            # Apenas limpeza b√°sica de dados
            dados_completos = self._limpar_dados_basicos(dados_completos)
            
            print(f"‚úÖ {len(dados_completos)} registros completos extra√≠dos")
            print(f"üìã Todas as colunas: {list(dados_completos.columns)}")
            
            return dados_completos
            
        except Exception as e:
            print(f"‚ùå Erro na extra√ß√£o: {str(e)}")
            return None
    
    def _limpar_dados_basicos(self, df):
        """Limpeza b√°sica dos dados mantendo todas as informa√ß√µes"""
        try:
            # Remove linhas completamente vazias
            df = df.dropna(how='all')
            
            # Converte datas se existir coluna de data
            colunas_data = [col for col in df.columns if any(palavra in col.lower() for palavra in ['data', 'date', 'timestamp'])]
            for col in colunas_data:
                try:
                    df[col] = pd.to_datetime(df[col], errors='coerce')
                except:
                    pass
            
            # Limpa espa√ßos em branco
            for col in df.select_dtypes(include=['object']).columns:
                df[col] = df[col].astype(str).str.strip()
            
            return df
            
        except Exception as e:
            print(f"‚ö†Ô∏è Erro na limpeza b√°sica: {str(e)}")
            return df
    
    def _extrair_sheet_id(self, url):
        """Extrai ID da planilha da URL"""
        try:
            pattern = r'/spreadsheets/d/([a-zA-Z0-9-_]+)'
            match = re.search(pattern, url)
            return match.group(1) if match else None
        except:
            return None
    
    def _detectar_colunas(self):
        """Detecta colunas automaticamente"""
        colunas = {}
        
        print("üîç Detectando colunas automaticamente...")
        print(f"üìã Colunas dispon√≠veis: {list(self.dados.columns)}")
        
        # Padr√µes para cada tipo de coluna
        padroes = {
            'data': ['data', 'date', 'timestamp', 'created', 'hora', 'time'],
            'nome': ['nome', 'name', 'client', 'customer', 'cliente'],
            'loja': ['loja', 'store', 'unidade', 'filial', 'shop'],
            'vendedor': ['vendedor', 'atendente', 'funcionario', 'staff', 'seller', 'funcion√°rio'],
            'avaliacao': ['avaliacao', 'avalia√ß√£o', 'nota', 'score', 'rating', 'nps', 'nota_nps', 'grade'],
            'classificacao': ['classificacao', 'classifica√ß√£o', 'category', 'tipo', 'class']
        }
        
        # Busca colunas
        for tipo, palavras in padroes.items():
            for coluna in self.dados.columns:
                coluna_lower = coluna.lower().strip()
                for palavra in palavras:
                    if palavra in coluna_lower:
                        colunas[tipo] = coluna
                        print(f"   ‚úÖ {tipo.upper()}: {coluna}")
                        break
                if tipo in colunas:
                    break
            
            if tipo not in colunas:
                print(f"   ‚ùå {tipo.upper()}: N√£o encontrada")
        
        # Verifica se tem pelo menos avalia√ß√£o
        if 'avaliacao' not in colunas:
            print("‚ö†Ô∏è ATEN√á√ÉO: Coluna de avalia√ß√£o n√£o encontrada!")
            print("üí° Certifique-se que sua planilha tem uma coluna com notas (0-10)")
            print("üìã Nomes aceitos: avaliacao, avalia√ß√£o, nota, score, rating, nps")
        
        return colunas
    
    def _limpar_dados(self, df):
        """Limpa e valida dados"""
        try:
            # Remove linhas vazias
            df = df.dropna(how='all')
            
            # Se tem coluna Avaliacao, converte para num√©rico
            if 'Avaliacao' in df.columns:
                df['Avaliacao'] = pd.to_numeric(df['Avaliacao'], errors='coerce')
                # Filtra apenas notas v√°lidas (0-10)
                df = df[(df['Avaliacao'] >= 0) & (df['Avaliacao'] <= 10)]
            
            # Converte Data se existe
            if 'Data' in df.columns:
                df['Data'] = pd.to_datetime(df['Data'], errors='coerce')
            
            # Remove linhas com dados cr√≠ticos faltando
            if 'Avaliacao' in df.columns:
                df = df.dropna(subset=['Avaliacao'])
            
            return df
            
        except Exception as e:
            print(f"‚ö†Ô∏è Erro na limpeza: {str(e)}")
            return df


def main():
    """Fun√ß√£o principal para teste"""
    extractor = NPSExtractor()
    
    # URL de teste
    url = input("Digite a URL do Google Sheets: ")
    
    # Conecta
    if extractor.conectar_sheets(url):
        # Extrai dados
        dados = extractor.extrair_avaliacoes()
        
        if dados is not None:
            print(f"\nüìä RESUMO DOS DADOS:")
            print(f"Total de registros: {len(dados)}")
            print(f"Colunas dispon√≠veis: {list(dados.columns)}")
            
            if 'Avaliacao' in dados.columns:
                print(f"Avalia√ß√µes v√°lidas: {dados['Avaliacao'].count()}")
                print(f"Nota m√©dia: {dados['Avaliacao'].mean():.2f}")
            
            # Salva amostra
            dados.head(10).to_csv('amostra_dados.csv', index=False)
            print(f"‚úÖ Amostra salva em: amostra_dados.csv")
        else:
            print("‚ùå Falha ao extrair dados")
    else:
        print("‚ùå Falha na conex√£o")


if __name__ == "__main__":
    main()